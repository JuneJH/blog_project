# 关于Fiber

> 在Fiber之前,react通过递归一次性更新所有的节点,不能中断。
>
> 浏览器的JS引擎与渲染引擎是互斥,因此当react更新节点时,浏览器无法进行渲染任务——(即无法处理用户输入,交互),页面会出现卡死的状态
>
> 只要当一个任务执行时间超过`16.6666ms`时,页面就会出现可见的卡顿

## 1. Fiber是什么

> `fiber`纤维,意在更细的组织,更小的组织单元,可控能力更强
> 在react16中Fiber也是一个vnode的数据结构
> 在Fiber这种数据结构中,通过`child`、`subling`、`return`三个属性来关联,形成可中断的链表数据结构

## 2. Fiber数据结构

 - type:节点类型,
 - key:标记了当前层级的唯一性
 - child:子节点,只有一个子节点
 - sibling:兄弟节点
 - return:标记上级节点
 - index:标记了当前层级下的位置
 - ...


## 3. window.requestIdleCallback

> window.requestIdleCallback()方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。 函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序。 --MDN

> 该API只是浏览器实验性API,因此不具有通用性

```js
// 任务列表
const taskQueue = [
    () => {
        console.log("run task 1");
        const curr = new Date();
        while (new Date() - curr < 30) {}
        console.log("run task 1 over");
    },
    () => {
        console.log("run task 2");
    },
    () => {
        console.log("run task 3");
    },
];

// 执行机制
function run(idleDeadline) {
    while (idleDeadline.timeRemaining() > 0 || idleDeadline.didTimeout) {
        if (taskQueue.length < 1) return;
        taskQueue.shift()();
    }
    // 如果还有任务再申请
    if (taskQueue.length > 0) {
        window.requestIdleCallback(run, { timeout: 1000 });
    }
}
window.requestIdleCallback(run, { timeout: 1000 });

```


## 4. 一个简单的react模型

> 在编写react程序时,会使用`JSX`,该语言生成一个个节点对象
> 把JSX对象转换为Fiber对象
> 把Fiber对象通过`child`、`sublin`、`return`属性关联起来,形成链表结构
> 把Fiber对象转换为真实DOM
> 通过`window.requestIdleCallback()`控制执行任务优先级



