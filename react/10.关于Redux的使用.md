# Redux 数据管理

> 后端的MVC模式
> 现代的React、vue等框架不适用MVC

## 1. 书写action

```js

    export const SETLOGINUSER = Symbol("set-login-user");
    export const SETTIMEOUT = Symbol("setTimeout");

    export const createLoginAction = (payload) => ({
        type: SETLOGINUSER,
        payload
    })
    // 使用thunk中间件支持action为一个函数
    export const effect = () => (
        function (dispatch, a, b) {
            dispatch(createLoginAction("马上设置"));
            setTimeout(() => {
                dispatch(createLoginAction("延后设置"))
            }, 3000);
        }
    )

```

## 2. 创建store

> 仓库:通过`createStore(reducer,?action)`创建,接受reducer和初始值

- dispatch: 分发执行reduce,参数为action
- getState: 得到仓库的值
- replaceReducer: 替换当前仓库的Reducer
- subscribe: 仓库值发生改变时触发,监听事件

## 3. 书写reduce


```js

    import * as loginAction from '../action/loginAction'
    const initialState = {
        loginUser: null,
    }

    export default (state = initialState, { type, payload }) => {
        console.log(type)
        switch (type) {

            case loginAction.SETLOGINUSER:
                return { ...state, ...payload }

            default:
                return state
        }
    }

```

## 3.简单使用

```js

    import {createStore} from 'redux';
    const action = {
        type:"IN"
    }
    function reducer(state,action){
        if(action.type === "In"){
            return state + 1;
        }else if(action.typ === "Out"){
            return state - 1;
        }
        return state;
    }

    const store = createStore(reducer,1); // 传入reducer和状态默认值,一个store只有一个state

    console.log(store.getState());
    store.dispatch(action);
    console.log(store.getState());

```

## 中间件

> 通过对`store.dispatch`重新赋值
> 在重新赋值的过程中保存之前的`store.dispatch`在中间件中合适的位置执行
> 利用函数组合合并多个中间件

### 1. redux-thunk

- 使用该中间件可以让action为函数,原理是当dispatch时,在该中间件执行时会把时函数的action执行后再处理,普通的acton将不做任何处理
- 使用该中间件必须为第一个

### 2. redux-logger

- 日志打印中间件

### 3. redux-action

### 4. redux-promise

### 5. redux-saga

> saga基于生成器实现,再redux使用中间件时,saga会维护一个任务机制
> 通过一系列指令来控制函数的执行
> 因此,当生成器运行完成时,saga也就结束了

1. 指令

- take: 监听某一个action,如果action发生了,take指令会有且执行一次,yield得到的是一个完成的action对象 **阻塞**
- all: 该指令接受一个数组,all指令会等其中所有指令完成后才会进行下一步流程 **阻塞**
- takeEvery: 不断的监听acition,当action触发时,运行一个函数,takeEvery不会结束当前生成器 **不会阻塞**


2. 使用

```js
    // 创建store
    const sagaMiddleware = createSagaMiddleware();
    const store = applyMiddleware(sagaMiddleware,logger)(createStore)(reducer);
    // 使用saga
    sagaMiddleware.run(saga)

 
    function* asyncIncrease(){
        console.log("触发了asyncIncrease")
    }

    function* asyncDecrease(){
        console.log("触发了asyncDecrease")
    }

    export default function*(){
        yield takeEvery(counterAction.INCREASE,asyncIncrease);
        yield takeEvery(counterAction.DECREASE,asyncDecrease);
        console.log("正在监听")
    }


```