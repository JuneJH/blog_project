# Redux 数据管理

> 后端的MVC模式
> 现代的React、vue等框架不适用MVC

## 1. 书写action

```js

export const SETLOGINUSER = Symbol("set-login-user");
export const SETTIMEOUT = Symbol("setTimeout");

export const createLoginAction = (payload) => ({
  type: SETLOGINUSER,
  payload
})
// 使用thunk中间件支持action为一个函数
export const effect = () => (
  function (dispatch, a, b) {
    dispatch(createLoginAction("马上设置"));
    setTimeout(() => {
      dispatch(createLoginAction("延后设置"))
    }, 3000);
  }
)

```

## 2. 创建store

> 仓库:通过`createStore(reducer,?action)`创建,接受reducer和初始值

- dispatch: 分发执行reduce,参数为action
- getState: 得到仓库的值
- replaceReducer: 替换当前仓库的Reducer
- subscribe: 仓库值发生改变时触发,监听事件

## 3. 书写reduce


```js
import * as loginAction from '../action/loginAction'
const initialState = {
  loginUser: null,
}

export default (state = initialState, { type, payload }) => {
  console.log(type)
  switch (type) {

    case loginAction.SETLOGINUSER:
      return { ...state, ...payload }

    default:
      return state
  }
}
```

## 3.简单使用

```js
import {createStore} from 'redux';
const action = {
  type:"IN"
}
function reducer(state,action){
  if(action.type === "In"){
    return state + 1;
  }else if(action.typ === "Out"){
    return state - 1;
  }
  return state;
}

const store = createStore(reducer,1); // 传入reducer和状态默认值,一个store只有一个state

console.log(store.getState());
store.dispatch(action);
console.log(store.getState());
```

## 4. react-action

> 用于简化action-type、action-creator、reducer的书写

- createAction
- createActions
- handleAction
- handleActions
- combineAction
## 3. 中间件

> 通过对`store.dispatch`重新赋值
> 在重新赋值的过程中保存之前的`store.dispatch`在中间件中合适的位置执行
> 利用函数组合合并多个中间件

### 1. redux-thunk

- 使用该中间件可以让action为函数,原理是当dispatch时,在该中间件执行时会把时函数的action执行后再处理,普通的acton将不做任何处理
- 使用该中间件必须为第一个

### 2. redux-logger

- 日志打印中间件

### 3. redux-saga

> saga基于生成器实现,再redux使用中间件时,saga会维护一个任务机制
> 通过一系列指令来控制函数的执行
> 因此,当生成器运行完成时,saga也就结束了

1. 指令

- take: 监听某一个action,如果action发生了,take指令会有且执行一次,yield得到的是一个完成的action对象 **阻塞**
- all: 该指令接受一个数组,all指令会等其中所有指令完成后才会进行下一步流程 **阻塞**
- takeEvery: 不断的监听acition,当action触发时,运行一个函数,takeEvery不会结束当前生成器 **不会阻塞**
- delay指令: 阻塞指定毫秒数执行**阻塞**
- put指令: 触发action相当于dispatch-action**不会阻塞**
- call指令: 调用函数 **取决于函数是否为副总用**
- apply指令: 同call,参数传递方式不一样
- select指令: 得到当前仓库中的数据
- cps指令: 用于调用传统的回调方式的异步函数
- fork指令: 开启一个新的任务,参数为一个生成器函数
- cancel指令: 取消任务
- takeLastest指令: 于takeEvery一致,只是执行一次后取消
- cancelled: 判读当前任务线是否被取消
- race指令: 与promise.race一致


2. 使用

```js
// 创建store
const sagaMiddleware = createSagaMiddleware();
const store = applyMiddleware(sagaMiddleware,logger)(createStore)(reducer);
// 使用saga
sagaMiddleware.run(saga)


function* asyncIncrease(){
  console.log("触发了asyncIncrease")
}

function* asyncDecrease(){
  console.log("触发了asyncDecrease")
}

export default function*(){
  yield takeEvery(counterAction.INCREASE,asyncIncrease);
  yield takeEvery(counterAction.DECREASE,asyncDecrease);
  console.log("正在监听")
}
```