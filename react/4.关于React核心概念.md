# React 核心概念

> React的复用、横切关注点、上下文等
> [官网Advanced Guides](https://reactjs.org/docs/getting-started.html)

## 1.高阶组件

> HOC:高阶组件，把组件作为参数，返回一个新的组件，可以用来给一些组件添加一些通用功能。
> 实现横切关注点

1. 实现为组件附加日志功能
   
```javascript

    // 实现添加日志
    import React from 'react'
    export default function withLog(Comp,option){
        return class LopWrapper extends React.Component{
            componentDidMount() {
                console.log(`日志：组件${Comp.name}被创建了！！${Date.now()}`)
            }
            componentWillUnmount() {
                console.log(`日志：组件${Comp.name}被销毁了！！！${Date.now()}`)
            }
            render(){
                return(
                    <>
                        <div>{option}</div> {/*显示其他信息*/}
                        <Comp/>
                    </>
                )
            }
        }
    }

```

**在调用高阶组件时，不要再render中调用，会导致多次销毁和创建状态丢失**
**不要在高阶组件中更改传入的组件,这会导致耦合**

## refs

> reference: 引用,用于获取真实DOM
>
> 需要使用DOM本身的属性或者方法时,比如调用`video``input`标签的属性
>
> 需要使用类组件实例的方法(将`ref`作用于类组件上时获取到该组件的实例)
> 
> 函数组件不能使用

1. 使用字符串方式

- 在组件上使用`ref`为字符串时,将在该组件实例中的`refs`属性中以该字符串为键,真实DOM或者组件实例为值
- 该方案已被销毁,不推荐使用
- 在`componentDidMount`之后就可以使用`ref`

示例

```js

    class A extends React.Component{

        constructor(props){
            super(props);
            console.log("constructor",this.refs.A); // 此时为undefined
        }

        componentWillMount(){
            console.log("componentWillMount",this.refs.A); // 此时为undefined
        }

        componentDidMount(){
            console.log("componentDidMount",this.refs.A); // 可访问
        }

        render(){
            console.log("render",this.refs.A); // 此时为undefined
            return (
            <div ref="A">
                <h1>this is A</h1>
            </div>
            )
        }
    }

```

2. 使用对象方式

- 该对象使用`React.createRef()`得到
- 该对象属性包括`current`

示例

```js

    class A extends React.Component{

        constructor(props){
            super(props);
            this.ARef = React.createRef();
            console.log("constructor",this.ARef);   // 此时该对象为空
        }

        componentWillMount(){
            console.log("componentWillMount",this.ARef);    // 此时该对象为空
        }

        componentDidMount(){
            console.log("componentDidMount",this.ARef); // 可访问
        }

        render(){
            console.log("render",this.ARef); // 此时该对象为空
            return (
            <div ref={this.ARef}>
                <h1>this is A</h1>
            </div>
            )
        }
    }


```

3. 使用函数的方式

- 为`ref`赋值一个函数,该函数的参数为真实DOM对象或者组件实例
- 该函数在渲染时如果得到不一样的函数,则会执行前一个函数一次参数为`null`,调用新的函数时参数为真实DOM或者组件实例
- 组件卸载时也会执行
- 该函数将在`render`后`componentDidMount`前执行,如果在更新阶段执行`render`后`componentDidUpdate`前

```js

    class A extends React.Component {

        constructor(props) {
            super(props);
            this.ARef = { current: null }
            console.log("constructor", this.ARef)
        }

        componentWillMount() {
            console.log("componentWillMount", this.ARef)
        }

        componentDidMount() {
            console.log("componentDidMount", this.ARef)
        }


        // 即将更新
        componentWillUpdate(props,state){
            console.log("componentWillUpdate",this.ARef)
        }

        componentDidUpdate(preProps,PreState){
            console.log("componentDidUpdate",this.ARef)
        }


        reRender() {
            this.setState({})
        }

        render() {
            console.log("render", this.ARef)
            return (
            <div ref={ref => {
                console.log("runRef", ref)
                this.ARef.current = ref 
            }}>
                <h1>this is A</h1>
                <button onClick={this.reRender.bind(this)}>刷新</button>
            </div>
            )
        }
    }

```

4. ref转发

- 在书写高阶组件时,运用`ref`得到的将是高阶组件的包裹层
- 利用ref转发,保证高阶组件不污染原组件
- 必须使用`React.forwardRef`进行转发,接受一个函数,该函数需要两个参数`props`/`ref`返回一个新组件

**转发函数组件**

```js

    function A (props,ref){
        console.log("转发的ref",ref)
        return (<div ref={ref}>
            <h1>this is A!!!</h1>
        </div>) 
    }

// 通过React.forwardRef转发,得到一个新的组件
    const NewA = React.forwardRef(A)
    class App extends React.Component{
        Aref = React.createRef();
        componentDidMount(){
            console.log("获取ref",this.Aref)
        }

        render(){
            return <NewA ref={this.Aref} />
        }
    }

```

**转发类组件**

```js

    class A extends React.Component {

        render() {
            return (<div ref={this.props.myRef}>
            <h1>this is class A!!!</h1>
            </div>)
        }
    }

    // 通过React.forwardRef转发,得到一个新的组件
    const NewA = React.forwardRef((props,ref)=>{
        return <A {...props} myRef={ref} />
    })
    class App extends React.Component {
        Aref = React.createRef();
        componentDidMount() {
            console.log("获取ref", this.Aref)
        }

        render() {
            return <NewA ref={this.Aref} />
        }
    }

```

- 通过`ref`转发避免高阶组件污染原组件的使用

## Context

> 当一个环境需要被多个或深层用到时
> 尽量保证数据来源单一

## PureComponent

## Render Props

## React 事件

## Portals

## 错误边界

## 渲染
   