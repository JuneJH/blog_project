# 生成器

> Es2015标准推出生成器概念
> 可在函数外界控制函数得执行

## 1. 迭代器和迭代协议

> 遍历: 对一个数组,map,set等数据集合一次性依次拿出所有数据
> 迭代: 根据某种方式随时随地取出数据

1. 迭代器

- Es2015规定,一个对象如果具有next()方法,且该next方法返回一个对象,该对象并且具备以下属性
- value:此次数据得值
- done:bool 是否已经迭代完成

```js

 const iterator = {
            total:3,
            i:0,
            next(){
                return{
                    value:this.i > this.total ? undefined : this.i++,
                    done:this.i > this.total
                }
            }
        }

```

2. 迭代器创建函数

> 一个返回迭代器得安徽念书

```js

 function createIterator(total){
            let i = 0;
            return {
              next(){
                return {
                    value:i > total ? undefined : i++,
                    done:i > total
                }
            }
            }
        }

```

3. 可迭代协议

> 满足可迭代协议的对象可以使用ES2015```for...of```循环
> ```for...of```循环使用[Symbol.iterator]创建迭代器,利用迭代器进行循环

- 对象必须存在一个知名符号的属性`Symbol iterator`
- 该属性必须为一个无参的迭代器创建函数、
- 满足以上就满足了可迭代协议

```js
        // 可迭代
        function createIterator(){
            let i = 0;
            let total = 3;
            return {
              next(){
                return {
                    value:i > total ? undefined : i++,
                    done:i > total
                }
            }
            }
        }


        const iterators = {
            total:3,
            [Symbol.iterator]:createIterator
        }

       for (const iterator of iterators) {
            console.log(iterator)
        }
        const i = iterators[Symbol.iterator]();
        let result = i.next();
        while(!result.done){
            console.log("for...of原理",result.value)
            result = i.next();
        }

```

## 2. 生成器