# 学习vue的生命周期

> 在创建vue实例时,在创建/更新的各个阶段Vue都向外暴露了钩子函数-生命周期函数
>
> 开发者可以在生命周期函数中完成一些业务需求,比如发送Ajax请求、清除定时器等
>
> 通过阅读源码看看vue在各个生命周期到底做了什么

## 1. beforeCreate

>  实例初始化后,即vue实例的基本属性,但是此时数据并没有响应式处理,配置项中的配置尚未处理

1. 在源码中调用`beforeCreate`前做了三件事

```js
    initLifecycle(vm)	// 初始化vue实例属性
    initEvents(vm)
    initRender(vm)
    callHook(vm, 'beforeCreate')
```

2. `initLisfecycle`该函数并非是做生命周期,只是做vue实例的初始化属性

```js
  vm.$parent = parent
  vm.$root = parent ? parent.$root : vm
  vm.$children = []
  vm.$refs = {}
  vm._watcher = null
  vm._inactive = null
  vm._directInactive = false
  vm._isMounted = false
  vm._isDestroyed = false
  vm._isBeingDestroyed = false
...
```

3. `initEvents`这里并非初始化自己的事件,而是初始化父级附加事件

```js
  const listeners = vm.$options._parentListeners
  if (listeners) {
    updateComponentListeners(vm, listeners)
  }
```

4. `initRender`向vue实例注入`h`函数

```js
vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false) // 内部使用
vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)// 开发者使用
```

5. 做完以上几个初始化动作后,就直接调用了`beforeCreate`钩子,所以在此阶段能做的事只能和vue相关实例属性有关或者与vue实例属性压根没有关系

## 2. created

>  数据已经做完响应式,配置项中的属性也都相应做了处理,此时一个vue实例基本已经完成

1. `created`

```js
    initInjections(vm) // 解析inject所需依赖
    initState(vm)
    initProvide(vm) // 注入Provide
    callHook(vm, 'created')
```

2. `initState`初始化数据,computed的数据是最后处理的所以它的优先级应该是最高的

```js
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props) // 先处理属性
  if (opts.methods) initMethods(vm, opts.methods) // 在处理methods
  if (opts.data) { // 处理data
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed)  // 处理computed
  if (opts.watch && opts.watch !== nativeWatch) { // 处理watch
    initWatch(vm, opts.watch)
  }
```

3. 在初始化数据时,虽然data是倒数第二处理的,但是在`initData`中对props中的key进行重复判断,如果props中存在该key则不对该key做处理

```js
// proxy data on instance
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  let i = keys.length
  while (i--) {
    const key = keys[i]
    if (props && hasOwn(props, key)) {
				// 做一些警告处理
    } else if (!isReserved(key)) {
      proxy(vm, `_data`, key)
    }
  }
  // observe data
  observe(data, true /* asRootData */)
```

4. 处理完以上任务后,直接调用`created`钩子函数,此时便可以访问数据
5. 接下来就是进行挂载,如果用户配置了`el`选项,会自动执行挂载方法,不用显示调用`$mount`

```js
    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
```



## 3. beforeMount

- 挂载之前调用

## 4. mounted

- 此时已经完成挂载,但是mounted不保证所有子组件都一起被挂载了

## 5. beforeDestroy

- 实例销毁之前调用

## 6. deserted

- 实例销毁后调用

## 7. beforeUpdate

- 数据更新时调用,在DOM打补丁之前

## 8. updated

- 数据完成更改并对虚拟DOM 重新渲染后