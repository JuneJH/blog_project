# 学习vue的生命周期

> 在创建vue实例时,创建/更新的各个阶段Vue都向外暴露了钩子函数-生命周期函数
>
> 开发者可以在生命周期函数中完成一些业务需求,比如发送Ajax请求、清除定时器等
>
> 通过阅读源码看看vue在各个生命周期到底做了什么

## 1. beforeCreate

>  实例初始化后,即vue实例的基本属性,但是此时数据并没有响应式处理,配置项中的配置尚未处理

1. 在源码中调用`beforeCreate`前做了三件事

```js
    initLifecycle(vm)	// 初始化vue实例属性
    initEvents(vm)
    initRender(vm)
    callHook(vm, 'beforeCreate')
```

2. `initLisfecycle`该函数并非是做生命周期,只是做vue实例的初始化属性

```js
  vm.$parent = parent
  vm.$root = parent ? parent.$root : vm
  vm.$children = []
  vm.$refs = {}
  vm._watcher = null
  vm._inactive = null
  vm._directInactive = false
  vm._isMounted = false
  vm._isDestroyed = false
  vm._isBeingDestroyed = false
...
```

3. `initEvents`初始化事件

```js
  const listeners = vm.$options._parentListeners // 事件是父组件在使用组件时注册
  if (listeners) {
    updateComponentListeners(vm, listeners) // 但是是组件内部触发
  }
```

4. `initRender`向vue实例注入`h`函数

```js
vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false) // 内部使用
vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)// 开发者使用
```

5. 做完以上几个初始化动作后,就直接调用了`beforeCreate`钩子,所以在此阶段能做的事只能和vue相关实例属性有关或者与vue实例属性压根没有关系

## 2. created

>  数据已经做完响应式,配置项中的属性也都相应做了处理,此时一个vue实例基本已经完成

1. `created`

```js
    initInjections(vm) // 解析inject所需依赖
    initState(vm)
    initProvide(vm) // 注入Provide
    callHook(vm, 'created')
```

2. `initState`初始化数据,computed的数据是最后处理的所以它的优先级应该是最高的

```js
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props) // 先处理属性
  if (opts.methods) initMethods(vm, opts.methods) // 在处理methods
  if (opts.data) { // 处理data
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed)  // 处理computed
  if (opts.watch && opts.watch !== nativeWatch) { // 处理watch
    initWatch(vm, opts.watch)
  }
```

3. 在初始化数据时,虽然data是倒数第二处理的,但是在`initData`中对props中的key进行重复判断,如果props中存在该key则不对该key做处理

```js
// proxy data on instance
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  let i = keys.length
  while (i--) {
    const key = keys[i]
    if (props && hasOwn(props, key)) {
				// 做一些警告处理
    } else if (!isReserved(key)) {
      proxy(vm, `_data`, key)
    }
  }
  // observe data
  observe(data, true /* asRootData */)
```

4. 在处理完状态之后调用`created`钩子函数,此时vue实例就拥有了以上数据
5. 在该函数的最后,如果用户配置了`el`选项,会自动执行挂载方法,不用显示调用`$mount`

```js
if (vm.$options.el) {
   vm.$mount(vm.$options.el)
 }
```

## 3. beforeMount

> 在挂载阶段,如果用户传递了`el`选项会在处理完数据后直接调用`mount`方法
>
> 挂载函数的基础方法在源码中`mountComponent`,差异的功能会通过不同环境进行配置

- 挂载之前调用,此时vue实例基本与运行`created`时大致相同,但是要多一些扩展`mountComponent`时所做的工作*根据平台的不一致性所有不同*

```js
  callHook(vm, 'beforeMount')
  let updateComponent
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = () => {
      const name = vm._name
      const id = vm._uid
      const startTag = `vue-perf-start:${id}`
      const endTag = `vue-perf-end:${id}`

      mark(startTag)
      const vnode = vm._render()
      mark(endTag)
      measure(`vue ${name} render`, startTag, endTag)

      mark(startTag)
      vm._update(vnode, hydrating)
      mark(endTag)
      measure(`vue ${name} patch`, startTag, endTag)
    }
  } else {
    updateComponent = () => {
      vm._update(vm._render(), hydrating)
    }
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, 'mounted')
  }
```



## 4. mounted

- 此时已经完成挂载,但是mounted不保证所有子组件都一起被挂载了

## 5. beforeDestroy

- 实例销毁之前调用

## 6. deserted

- 实例销毁后调用

## 7. beforeUpdate

- 数据更新时调用,在DOM打补丁之前

## 8. updated

- 数据完成更改并对虚拟DOM 重新渲染后