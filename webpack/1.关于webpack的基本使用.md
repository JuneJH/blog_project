# webpack基本使用

> webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。

## 1. 基本概念

- entry: 打包入口
- output: 输出配置
- module: 加载器,使webpack能处理任何文件
- plugins: 实现各种功能,为loader处理后的文件赋能
- chunk: 一个模块的输出,可能会分成多个文件,但是他们应该属于一个chunk
- bundle: 输出的文件
- webpack指纹文件: hash、chunkhash、contenthash
- - hash: 项目级别
  - chunkhash: chunk组发生变化
  - contenthash: 单个文件发生变化 

## 2. 基本配置

### 1. entry

> 入口配置,支持字符串、数组、对象,其中对象可以配置多页面应用
>
> 数组和字符串模式都只有一个输出

- 1.字符串方式

```js
entry:"./main.js"
```

- 2.数组方式

```js
entry:["./main1.js","./main.js"] 
```

- 3.对象方式

```js
entry:{
  "entry1":"./main1.js",
  "entry2":"./main.js"
}
```

### 2. output

> 输出配置
>
> 即使可以存在多个入口起点，也只能指定一个输出配置

```js
output:{
  path:path.resolve(__dirname,"./bundle"),
  filename:"[name].js"
}
```

### 3. loader

> 默认情况下webpack只能处理js、json,但是通过lodader,webpack有能力处理任何文件
>
> 其中一个有效的loader不能为箭头函数 (内部需要使用this)且需要返回一个字符串或者流

```js
module:{
  rules: [
    { test: /\.css$/, use: 'css-loader' }
  ]
}
```

### 4. plugins

> webpack通过loader认识处理各种文件,通过plugin为这些文件赋能

```js
plugins: [new HtmlWebpackPlugin()],
```



### 5. mode

> 设置打包的环境，none、development、prodution

```js
mode: "development"
```

### 6. devserve

> 配置本地服务、热更新、代理

```js
devServer: {
 contentBase: "./dist", // 资源地址
 open: true, // 自动打开浏览器
 port: 8081, // 端口 port: 8081 // 端口
 proxy: { // 配置代理
	"/api": {
			target: "http://localhost:3000"
 		}
 }
},
```

### 7. devtool

> 源代码与打包后的代码位置映射关系

```js
devtool:"none" // 默认值
devtool:"cheap-module-eval-source-map",// 通常使用开发环境配置
devtool:"cheap-module-source-map", // 通常使用线上⽣成配置
```

## 3. 实现一个loader

> loader不能是箭头函数且需要返回一个字符串或者buffer(可以通过return或者`this.callback()`返回)
>
> loader处理异步使用`this.async`

### 1. 实现一个替换字符串

```js
function (str){
    const callback = this.async();
    const res =  str.replace("name","junejh");
    setTimeout(()=>{
        callback(null,res);
    },100);
}
```

## 4. 实现一个plugin

> webpack在编译的时候会触发一系列 Tapable钩子,书写插件时根据自身功能找到自己需要执行的时机并在该钩子上注册插件任务,当钩子执行时会触发该任务
>
> plugin是⼀个类,通过apply函数接受⼀个参数compiler

### 1. 增加获取打包清单列表

```js
class fileListPlugin {
    constructor(filename = "filelist.txt"){
        this.filename = filename
    }
    apply(compiler){
        compiler.hooks.emit.tap("filelist",compilation=>{
            const result = Object.entries(compilation.assets).map(([key,val])=>{
                return `【${key}】    ===>    ${val.size()}`
            })

            compilation.assets[this.filename] = {
                source(){
                    return result.join("\n\n\n")
                },
                size(){
                    return result.length;
                }
            }
        })
    }
}
```

